<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Offside Calculator Pro v3.2 ‚öΩ</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='g' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%2300ff87'/%3E%3Cstop offset='100%25' style='stop-color:%2300b894'/%3E%3C/linearGradient%3E%3C/defs%3E%3Crect width='100' height='100' rx='20' fill='%230f172a'/%3E%3Cline x1='10' y1='80' x2='50' y2='30' stroke='%233b82f6' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='30' y1='85' x2='50' y2='30' stroke='%233b82f6' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='50' y1='90' x2='50' y2='30' stroke='%233b82f6' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='70' y1='85' x2='50' y2='30' stroke='%233b82f6' stroke-width='3' stroke-linecap='round'/%3E%3Cline x1='90' y1='80' x2='50' y2='30' stroke='%233b82f6' stroke-width='3' stroke-linecap='round'/%3E%3Ccircle cx='50' cy='30' r='6' fill='url(%23g)' stroke='%2300ff87' stroke-width='2'/%3E%3Cpath d='M 35 55 L 40 45 L 45 55 L 40 50 Z' fill='%23f97316' opacity='0.8'/%3E%3Cpath d='M 60 60 Q 65 50 70 60' stroke='%2322d3ee' stroke-width='2' fill='none' stroke-dasharray='2,2'/%3E%3C/svg%3E">
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700;800&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #00ff87;
      --primary-dark: #00cc6a;
      --secondary: #7c3aed;
      --accent: #f97316;
      --cyan: #22d3ee;
      --danger: #ef4444;
      --bg-dark: #0f172a;
      --bg-card: #1e293b;
      --bg-hover: #334155;
      --text: #f8fafc;
      --text-muted: #94a3b8;
      --border: #475569;
      --gradient-1: linear-gradient(135deg, #00ff87 0%, #00b894 100%);
      --gradient-2: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      overflow: hidden;
      height: 100vh;
    }
    
    .header {
      background: linear-gradient(180deg, rgba(15, 23, 42, 0.98) 0%, rgba(15, 23, 42, 0.95) 100%);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--border);
      padding: 0.75rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      z-index: 100;
    }
    
    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-family: 'Montserrat', sans-serif;
      font-weight: 800;
      font-size: 1.125rem;
      background: var(--gradient-1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .logo-icon {
      width: 32px;
      height: 32px;
      background: var(--gradient-1);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      -webkit-text-fill-color: var(--bg-dark);
    }
    
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.625rem 1rem;
      border-radius: 10px;
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      font-size: 0.8125rem;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .btn-primary {
      background: var(--gradient-1);
      color: var(--bg-dark);
      box-shadow: 0 4px 15px rgba(0, 255, 135, 0.3);
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 255, 135, 0.4);
    }
    
    .btn-secondary {
      background: var(--bg-card);
      color: var(--text);
      border: 1px solid var(--border);
    }
    
    .btn-secondary:hover {
      background: var(--bg-hover);
      border-color: var(--primary);
    }
    
    .btn-ghost {
      background: transparent;
      color: var(--text-muted);
      border: 1px solid transparent;
    }
    
    .btn-ghost:hover {
      color: var(--text);
      background: var(--bg-card);
    }
    
    .tool-group {
      display: flex;
      background: var(--bg-card);
      border-radius: 12px;
      padding: 4px;
      gap: 2px;
    }
    
    .tool-btn {
      width: 42px;
      height: 42px;
      border-radius: 8px;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1.25rem;
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .tool-btn:hover {
      color: var(--text);
      background: var(--bg-hover);
    }
    
    .tool-btn.active {
      background: var(--gradient-1);
      color: var(--bg-dark);
      box-shadow: 0 2px 10px rgba(0, 255, 135, 0.3);
    }
    
    .tool-btn svg {
      width: 20px;
      height: 20px;
    }
    
    .divider {
      width: 1px;
      height: 32px;
      background: var(--border);
      margin: 0 0.5rem;
    }
    
    .stats {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-left: auto;
      font-size: 0.8125rem;
    }
    
    .stat-item {
      display: flex;
      align-items: center;
      gap: 0.375rem;
    }
    
    .stat-dot { width: 10px; height: 10px; border-radius: 50%; }
    .stat-dot.source { background: #3b82f6; }
    .stat-dot.vp { background: var(--accent); }
    
    .vp-coords {
      background: var(--bg-card);
      padding: 0.375rem 0.75rem;
      border-radius: 8px;
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      color: var(--primary);
      font-size: 0.75rem;
    }
    
    .main {
      display: flex;
      height: calc(100vh - 65px);
    }
    
    .canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: 
        radial-gradient(circle at 50% 50%, rgba(0, 255, 135, 0.03) 0%, transparent 50%),
        linear-gradient(180deg, #0f172a 0%, #1a1f35 100%);
    }
    
    .canvas-container canvas {
      width: 100%;
      height: 100%;
    }
    
    .sidebar {
      width: 280px;
      background: var(--bg-card);
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .sidebar-section {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }
    
    .sidebar-title {
      font-family: 'Montserrat', sans-serif;
      font-weight: 700;
      font-size: 0.6875rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
    }
    
    .vp-info {
      background: var(--bg-dark);
      border-radius: 10px;
      padding: 0.875rem;
    }
    
    .vp-info-row {
      display: flex;
      justify-content: space-between;
      font-size: 0.8125rem;
      margin-bottom: 0.375rem;
    }
    
    .vp-info-label { color: var(--text-muted); }
    .vp-info-value { font-weight: 600; font-family: 'Montserrat', sans-serif; }
    
    .vp-status {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      font-size: 0.75rem;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--border);
    }
    
    .vp-status.inside { color: var(--primary); }
    .vp-status.outside { color: var(--accent); }
    
    .sidebar-btn {
      width: 100%;
      margin-top: 0.75rem;
    }
    
    .export-grid {
      display: grid;
      gap: 0.5rem;
    }
    
    .lang-toggle {
      display: flex;
      background: var(--bg-dark);
      border-radius: 8px;
      padding: 3px;
      font-size: 0.75rem;
    }
    
    .lang-btn {
      flex: 1;
      padding: 0.375rem 0.75rem;
      border: none;
      background: transparent;
      color: var(--text-muted);
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.15s ease;
    }
    
    .lang-btn.active {
      background: var(--primary);
      color: var(--bg-dark);
    }
    
    .shortcuts {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }
    
    .shortcut-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      font-size: 0.8125rem;
      border-bottom: 1px solid rgba(71, 85, 105, 0.3);
    }
    
    .shortcut-key {
      background: var(--bg-dark);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      font-size: 0.6875rem;
      color: var(--primary);
    }
    
    .status-bar {
      background: var(--bg-card);
      border-top: 1px solid var(--border);
      padding: 0.5rem 1rem;
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .status-hint {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .status-hint::before {
      content: '';
      width: 6px;
      height: 6px;
      background: var(--primary);
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }
    
    .help-btn {
      position: fixed;
      bottom: 60px;
      right: 296px;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: var(--gradient-2);
      border: none;
      color: white;
      font-size: 1.25rem;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(124, 58, 237, 0.4);
      transition: all 0.2s ease;
      z-index: 50;
    }
    
    .help-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 25px rgba(124, 58, 237, 0.5);
    }
    
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(4px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .modal-overlay.open {
      opacity: 1;
      visibility: visible;
    }
    
    .modal {
      background: var(--bg-card);
      border-radius: 16px;
      width: 90%;
      max-width: 800px;
      max-height: 85vh;
      overflow: hidden;
      transform: translateY(20px) scale(0.95);
      transition: all 0.3s ease;
      border: 1px solid var(--border);
    }
    
    .modal-overlay.open .modal {
      transform: translateY(0) scale(1);
    }
    
    .modal-header {
      background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-card) 100%);
      padding: 1.5rem;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    
    .modal-title {
      font-family: 'Montserrat', sans-serif;
      font-weight: 800;
      font-size: 1.5rem;
      background: var(--gradient-1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .modal-close {
      width: 36px;
      height: 36px;
      border-radius: 8px;
      background: var(--bg-hover);
      border: none;
      color: var(--text);
      font-size: 1.25rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .modal-close:hover {
      background: var(--danger);
    }
    
    .modal-tabs {
      display: flex;
      background: var(--bg-dark);
      padding: 0.5rem;
      gap: 0.25rem;
    }
    
    .modal-tab {
      flex: 1;
      padding: 0.75rem;
      border: none;
      background: transparent;
      color: var(--text-muted);
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      font-size: 0.8125rem;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .modal-tab:hover {
      color: var(--text);
    }
    
    .modal-tab.active {
      background: var(--gradient-1);
      color: var(--bg-dark);
    }
    
    .modal-content {
      padding: 1.5rem;
      overflow-y: auto;
      max-height: calc(85vh - 140px);
    }
    
    .guide-section { margin-bottom: 2rem; }
    .guide-section h3 {
      font-family: 'Montserrat', sans-serif;
      font-weight: 700;
      font-size: 1.125rem;
      margin-bottom: 0.75rem;
      color: var(--primary);
      display: flex; align-items: center; gap: 0.5rem;
    }
    .guide-section p, .guide-section li {
      color: var(--text-muted);
      line-height: 1.7;
      margin-bottom: 0.75rem;
    }
    .guide-section ul { padding-left: 1.5rem; }
    
    .guide-highlight {
      background: var(--bg-dark);
      border-left: 3px solid var(--primary);
      padding: 1rem;
      border-radius: 0 8px 8px 0;
      margin: 1rem 0;
    }
    
    .guide-step {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
      align-items: flex-start;
    }
    
    .guide-step-num {
      width: 32px;
      height: 32px;
      background: var(--gradient-1);
      color: var(--bg-dark);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: 'Montserrat', sans-serif;
      font-weight: 800;
      flex-shrink: 0;
    }
    
    .guide-step-content h4 { font-weight: 600; margin-bottom: 0.25rem; color: var(--text); }
    .guide-step-content p { margin: 0; font-size: 0.875rem; }
    
    .zoom-indicator {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      background: var(--bg-card);
      padding: 0.5rem 0.75rem;
      border-radius: 8px;
      font-family: 'Montserrat', sans-serif;
      font-weight: 600;
      font-size: 0.75rem;
      color: var(--text-muted);
      border: 1px solid var(--border);
    }
    
    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: var(--text-muted);
      pointer-events: none;
    }
    
    .empty-state-icon { font-size: 4rem; margin-bottom: 1rem; opacity: 0.3; }
    .empty-state h3 {
      font-family: 'Montserrat', sans-serif;
      font-weight: 700;
      font-size: 1.25rem;
      margin-bottom: 0.5rem;
      color: var(--text);
    }
    
    @media (max-width: 768px) {
      .sidebar { display: none; }
      .help-btn { right: 1rem; }
      .stats { display: none; }
    }
  </style>
</head>
<body>
  <header class="header">
    <div class="logo">
      <div class="logo-icon">‚öΩ</div>
      Offside Calc
    </div>
    
    <div class="divider"></div>
    
    <button class="btn btn-primary" id="btnOpen">
      <span>üìÇ</span>
      <span data-i18n="openImage">Open Image</span>
    </button>
    <input type="file" id="fileInput" accept="image/*" style="display:none">
    
    <div class="divider"></div>
    
    <div class="tool-group">
      <button class="tool-btn active" data-tool="select" title="Select (V)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"/></svg>
      </button>
      <button class="tool-btn" data-tool="draw" title="Reference Line (L)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="19" x2="19" y2="5"/></svg>
      </button>
      <button class="tool-btn" data-tool="vpLine" title="Offside Line (P)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="3"/><line x1="12" y1="2" x2="12" y2="6"/><line x1="12" y1="18" x2="12" y2="22"/><line x1="2" y1="12" x2="6" y2="12"/><line x1="18" y1="12" x2="22" y2="12"/></svg>
      </button>
      <button class="tool-btn" data-tool="player" title="Player Projection (Y)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="5" r="3"/><line x1="12" y1="8" x2="12" y2="21"/><line x1="8" y1="21" x2="16" y2="21"/></svg>
      </button>
      <button class="tool-btn" data-tool="delete" title="Delete (D)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3,6 5,6 21,6"/><path d="M19,6v14a2,2,0,0,1-2,2H7a2,2,0,0,1-2-2V6m3,0V4a2,2,0,0,1,2-2h4a2,2,0,0,1,2,2v2"/></svg>
      </button>
      <button class="tool-btn" data-tool="pan" title="Pan (H)">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>
      </button>
    </div>
    
    <div class="divider"></div>
    
    <div class="tool-group">
      <button class="tool-btn" id="btnUndo" title="Undo"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg></button>
      <button class="tool-btn" id="btnRedo" title="Redo"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg></button>
    </div>
    
    <div class="divider"></div>
    
    <div class="tool-group">
      <button class="tool-btn" id="btnZoomOut" title="Zoom Out"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
      <button class="tool-btn" id="btnZoomIn" title="Zoom In"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg></button>
      <button class="tool-btn" id="btnFit" title="Fit to View"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg></button>
    </div>
    
    <div class="stats">
      <div class="stat-item"><div class="stat-dot source"></div><span data-i18n="sourceLines">Source</span>: <strong id="sourceCount">0</strong></div>
      <div class="stat-item"><div class="stat-dot vp"></div><span>VP</span>: <strong id="vpCount">0</strong></div>
      <div class="vp-coords" id="vpCoords">VP: --</div>
    </div>
  </header>
  
  <main class="main">
    <div class="canvas-container" id="canvasContainer">
      <canvas id="canvas"></canvas>
      <div class="empty-state" id="emptyState">
        <div class="empty-state-icon">‚öΩ</div>
        <h3 data-i18n="emptyTitle">Load an image to begin</h3>
        <p data-i18n="emptyDesc">Click "Open Image" or drag & drop</p>
      </div>
      <div class="zoom-indicator" id="zoomIndicator">100%</div>
    </div>
    
    <aside class="sidebar">
      <div class="sidebar-section">
        <div class="sidebar-title" data-i18n="language">Language</div>
        <div class="lang-toggle">
          <button class="lang-btn active" data-lang="en">English</button>
          <button class="lang-btn" data-lang="it">Italiano</button>
        </div>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-title" data-i18n="vanishingPoint">Vanishing Point</div>
        <div class="vp-info" id="vpInfo">
          <div class="vp-info-row"><span class="vp-info-label">X:</span><span class="vp-info-value" id="vpX">--</span></div>
          <div class="vp-info-row"><span class="vp-info-label">Y:</span><span class="vp-info-value" id="vpY">--</span></div>
          <div class="vp-status" id="vpStatus"><span data-i18n="drawLines">Draw at least 2 lines</span></div>
        </div>
        <button class="btn btn-secondary sidebar-btn" id="btnRecalc"><span data-i18n="recalculate">Recalculate</span></button>
      </div>
      
      <div class="sidebar-section">
        <div class="sidebar-title" data-i18n="export">Export</div>
        <div class="export-grid">
          <button class="btn btn-secondary" id="btnExport" data-i18n="exportImage">Export Image</button>
          <button class="btn btn-secondary" id="btnExportExt" data-i18n="exportExtended">Export Extended</button>
        </div>
      </div>
      
      <div class="shortcuts">
        <div class="sidebar-title" data-i18n="shortcuts">Shortcuts</div>
        <div class="shortcut-item"><span data-i18n="select">Select</span><span class="shortcut-key">V</span></div>
        <div class="shortcut-item"><span data-i18n="drawLine">Draw Line</span><span class="shortcut-key">L</span></div>
        <div class="shortcut-item"><span data-i18n="vpLineShort">VP Line</span><span class="shortcut-key">P</span></div>
        <div class="shortcut-item"><span data-i18n="playerTool">Player</span><span class="shortcut-key">Y</span></div>
        <div class="shortcut-item"><span data-i18n="deleteTool">Delete</span><span class="shortcut-key">D</span></div>
        <div class="shortcut-item"><span data-i18n="panTool">Pan</span><span class="shortcut-key">H</span></div>
        <div class="shortcut-item"><span data-i18n="moveVP">Move VP</span><span class="shortcut-key">‚Üë‚Üì‚Üê‚Üí</span></div>
        <div class="shortcut-item"><span data-i18n="undo">Undo</span><span class="shortcut-key">Ctrl+Z</span></div>
        <div class="shortcut-item"><span data-i18n="help">Help</span><span class="shortcut-key">F1</span></div>
      </div>
    </aside>
  </main>
  
  <footer class="status-bar">
    <div class="status-hint" id="statusHint" data-i18n="statusSelect">Click to select. Drag VP or use arrow keys.</div>
    <button class="btn btn-ghost" id="btnTutorial" data-i18n="startTutorial">üéì Tutorial</button>
  </footer>
  
  <button class="help-btn" id="btnHelp" title="Help (F1)">?</button>
  
  <div class="modal-overlay" id="helpModal">
    <div class="modal">
      <div class="modal-header">
        <h2 class="modal-title" data-i18n="guideTitle">User Guide</h2>
        <button class="modal-close" id="btnCloseHelp">‚úï</button>
      </div>
      <div class="modal-tabs">
        <button class="modal-tab active" data-tab="quickstart" data-i18n="tabQuickstart">Quick Start</button>
        <button class="modal-tab" data-tab="theory" data-i18n="tabTheory">Theory</button>
        <button class="modal-tab" data-tab="tools" data-i18n="tabTools">Tools</button>
        <button class="modal-tab" data-tab="about" data-i18n="tabAbout">About</button>
      </div>
      <div class="modal-content" id="modalContent"></div>
    </div>
  </div>

<script>
const i18n = {
  en: {
    openImage: "Open Image", sourceLines: "Source", language: "Language", vanishingPoint: "Vanishing Point",
    drawLines: "Draw at least 2 lines", insideImage: "‚úì Inside image", outsideImage: "‚ö† Outside image",
    recalculate: "Recalculate", export: "Export", exportImage: "Image with Lines", exportExtended: "Extended (with VP)",
    shortcuts: "Shortcuts", select: "Select", drawLine: "Ref Line", vpLineShort: "Offside Line", playerTool: "Player Proj.", deleteTool: "Delete",
    panTool: "Pan", moveVP: "Move VP", zoom: "Zoom", undo: "Undo", help: "Help",
    statusSelect: "Click to select. Drag VP or use arrow keys.", statusDraw1: "Click first point of line.",
    statusDraw2: "Click second point.", statusVP: "Click to create line from VP.", statusVPNone: "No VP. Draw lines first.",
    statusPlayer1: "Click offside body part (e.g. shoulder).", statusPlayer2: "Click point on ground.",
    statusDelete: "Click on a line to delete.", statusPan: "Drag to pan.", startTutorial: "üéì Tutorial",
    guideTitle: "Pro User Guide", tabQuickstart: "Quick Start", tabTheory: "Master Theory", tabTools: "Toolbox", tabAbout: "About",
    emptyTitle: "Load an image to begin", emptyDesc: "Click 'Open Image' or drag & drop",
    quickstartContent: `<div class="guide-section"><h3>üöÄ Quick Workflow</h3><p>Follow these steps for a professional analysis:</p><div class="guide-step"><div class="guide-step-num">1</div><div class="guide-step-content"><h4>Image Setup</h4><p>Use high-resolution images where pitch markings are clearly visible. Low-res screenshots can lead to inaccurate VP calculations.</p></div></div><div class="guide-step"><div class="guide-step-num">2</div><div class="guide-step-content"><h4>Calibration (Ref Lines)</h4><p>Press <strong>L</strong>. Draw at least 2 (preferably 3-4) <strong>Blue Lines</strong> along the horizontal pitch markings (penalty box, grass cutting patterns). <br><em>Tip: Lines far apart give better accuracy than lines close together.</em></p></div></div><div class="guide-step"><div class="guide-step-num">3</div><div class="guide-step-content"><h4>Verify Vanishing Point</h4><p>Check the Green Crosshair (VP). It should align with the horizon. If it looks wrong, delete and redraw the reference lines, or move the VP manually (V).</p></div></div><div class="guide-step"><div class="guide-step-num">4</div><div class="guide-step-content"><h4>Player Analysis (New!)</h4><p>Press <strong>Y</strong>. <br>1. Click the player's offside body part (e.g. Shoulder).<br>2. Move down and click exactly where that point projects on the ground.<br>3. The Cyan segment marks the height, and the Orange line shows the offside position.</p></div></div></div>`,
    theoryContent: `<div class="guide-section"><h3>üìê The Physics of Offside</h3><p>Understanding 2D projections of 3D space is key to VAR analysis.</p><div class="guide-highlight"><strong>What is the Vanishing Point (VP)?</strong><br>In a perspective image, all lines that are parallel in reality (like the 18-yard line, the midfield line, and the mowing patterns) converge to a single point. This is the VP.</div><h3>üß™ The Parallax Error</h3><p>Why can't I just draw a line from the player's head?</p><ul><li><strong>The Ground Truth:</strong> Offside lines exist on the <em>pitch surface</em> (z=0).</li><li><strong>Projection:</strong> If a player is leaning, their head is "above" the line. We must project that point vertically down to the ground to find their effective position.</li></ul><p>Our <strong>Player Tool (Y)</strong> solves this: it forces you to define the "Body-to-Ground" segment (Cyan), and calculates the Offside Line (Orange) from the ground point, ensuring perspective accuracy.</p></div>`,
    toolsContent: `<div class="guide-section"><h3>üîß Detailed Tool Reference</h3><div class="guide-step"><div class="guide-step-num">‚Üñ</div><div class="guide-step-content"><h4>Select / Move VP (V)</h4><p>Allows you to tweak the calculation.<br>‚Ä¢ <strong>Drag:</strong> Move VP with mouse.<br>‚Ä¢ <strong>Arrows:</strong> 1px precision move.<br>‚Ä¢ <strong>Shift+Arrows:</strong> 10px fast move.</p></div></div><div class="guide-step"><div class="guide-step-num">/</div><div class="guide-step-content"><h4>Reference Line (L)</h4><p><strong>Blue Lines.</strong> Draw these on ANY horizontal line on the pitch. <br><em>Note: Do not draw on vertical touchlines! Only horizontal lines converge to the Offside VP.</em></p></div></div><div class="guide-step"><div class="guide-step-num">‚õπ</div><div class="guide-step-content"><h4>Player Projection (Y)</h4><p><strong>The Pro Tool.</strong><br>‚Ä¢ <strong>Click 1:</strong> Body Part (Head/Shoulder/Knee).<br>‚Ä¢ <strong>Click 2:</strong> Ground Point.<br>‚Ä¢ <strong>Result:</strong> Creates a dotted Cyan segment (height) and the final Orange Offside line.</p></div></div><div class="guide-step"><div class="guide-step-num">‚äï</div><div class="guide-step-content"><h4>Manual Offside Line (P)</h4><p><strong>Orange Line.</strong> Useful if you only want to check a specific point on the ground without drawing the body projection.</p></div></div><div class="guide-step"><div class="guide-step-num">üîç</div><div class="guide-step-content"><h4>Smart Magnifier</h4><p>Activates automatically when drawing. It now allows you to see <strong>outside the image borders</strong>, making it easier to select pixels at the very edge of the screenshot.</p></div></div></div>`,
    aboutContent: `<div class="guide-section"><h3>‚öΩ Offside Calculator Pro</h3><p>Version 3.2 - A professional web-based tool for analyzing offside positions in soccer using perspective geometry and vanishing point calculations.</p><div class="guide-highlight"><strong>Open Source Project</strong><br>This tool is free and open source under the MIT License. You can use, modify, and distribute it freely.</div><h3>üë®‚Äçüíª Developer</h3><p><strong>Marco Verde</strong><br>Passionate about the intersection of mathematics, computer vision, and the beautiful game.</p><h3>üîó Links</h3><p>‚Ä¢ <strong>GitHub Repository:</strong> <a href="https://github.com/maverde73/offside-calculator" target="_blank" style="color: #00ff87;">github.com/maverde73/offside-calculator</a><br>‚Ä¢ <strong>Report Issues:</strong> Found a bug? Have a suggestion? Open an issue on GitHub!<br>‚Ä¢ <strong>Contribute:</strong> Pull requests are welcome!</p><h3>üìú License</h3><p>MIT License ¬© 2026 Marco Verde<br>See LICENSE file for full details.</p><h3>üôè Acknowledgments</h3><p>Built with ‚ù§Ô∏è using vanilla JavaScript and HTML5 Canvas. Special thanks to the open source community and all contributors.</p><p style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border); color: var(--text-muted); font-size: 0.875rem;"><em>Note: This tool is for educational and analytical purposes. Official match decisions are made by qualified referees using professional VAR systems.</em></p></div>`
  },
  it: {
    openImage: "Apri Immagine", sourceLines: "Sorgente", language: "Lingua", vanishingPoint: "Punto di Fuga",
    drawLines: "Disegna almeno 2 linee", insideImage: "‚úì Dentro l'immagine", outsideImage: "‚ö† Fuori dall'immagine",
    recalculate: "Ricalcola", export: "Esporta", exportImage: "Immagine con Linee", exportExtended: "Estesa (con VP)",
    shortcuts: "Scorciatoie", select: "Seleziona", drawLine: "Riferimento", vpLineShort: "Linea F.G.", playerTool: "Proiezione", deleteTool: "Elimina",
    panTool: "Sposta", moveVP: "Muovi VP", zoom: "Zoom", undo: "Annulla", help: "Aiuto",
    statusSelect: "Clicca per selezionare. Trascina VP o usa le frecce.", statusDraw1: "Clicca il primo punto.",
    statusDraw2: "Clicca il secondo punto.", statusVP: "Clicca per creare linea da VP.", statusVPNone: "Nessun VP. Disegna linee prima.",
    statusPlayer1: "Clicca parte del corpo (es. spalla).", statusPlayer2: "Clicca punto a terra.",
    statusDelete: "Clicca su una linea per eliminarla.", statusPan: "Trascina per spostare.", startTutorial: "üéì Tutorial",
    guideTitle: "Manuale Pro", tabQuickstart: "Guida Rapida", tabTheory: "Masterclass Teoria", tabTools: "Strumenti", tabAbout: "Info",
    emptyTitle: "Carica un'immagine", emptyDesc: "Clicca 'Apri Immagine' o trascina qui",
    quickstartContent: `<div class="guide-section"><h3>üöÄ Flusso di Lavoro Professionale</h3><p>Segui questi passaggi per un'analisi precisa:</p><div class="guide-step"><div class="guide-step-num">1</div><div class="guide-step-content"><h4>Caricamento</h4><p>Usa screenshot HD. Pi√π le linee del campo sono visibili, migliore sar√† il risultato.</p></div></div><div class="guide-step"><div class="guide-step-num">2</div><div class="guide-step-content"><h4>Calibrazione (Ref Lines)</h4><p>Premi <strong>L</strong>. Traccia almeno 2 (meglio 3 o 4) <strong>Linee Blu</strong> sulle marcature orizzontali del campo (area di rigore, linee di taglio dell'erba). <br><em>Consiglio: Linee distanti tra loro offrono una precisione geometrica superiore.</em></p></div></div><div class="guide-step"><div class="guide-step-num">3</div><div class="guide-step-content"><h4>Verifica VP</h4><p>Controlla il mirino verde (VP). Deve trovarsi sull'orizzonte prospettico. Se sembra sbagliato, elimina le linee blu e rifalle, o sposta il VP manualmente (tasto V).</p></div></div><div class="guide-step"><div class="guide-step-num">4</div><div class="guide-step-content"><h4>Analisi Giocatore (Novit√†!)</h4><p>Premi <strong>Y</strong>. <br>1. Clicca sulla parte del corpo in fuorigioco (es. Spalla).<br>2. Spostati in basso e clicca ESATTAMENTE dove quel punto cade a terra.<br>3. Il segmento Ciano mostra l'altezza, la linea Arancione √® il fuorigioco.</p></div></div></div>`,
    theoryContent: `<div class="guide-section"><h3>üìê La Fisica del Fuorigioco</h3><p>Capire la proiezione 2D di uno spazio 3D √® fondamentale per l'analisi VAR.</p><div class="guide-highlight"><strong>Cos'√® il Punto di Fuga (VP)?</strong><br>In una foto prospettica, tutte le linee che nella realt√† sono parallele (come la linea di porta, quella di centrocampo e i tagli dell'erba) convergono in un unico punto. Questo √® il VP.</div><h3>üß™ Errore di Parallasse</h3><p>Perch√© non posso tirare una linea direttamente dalla testa del giocatore?</p><ul><li><strong>La Verit√† del Terreno:</strong> Le linee di fuorigioco esistono solo sul <em>piano del campo</em> (z=0).</li><li><strong>Proiezione:</strong> Se un giocatore √® inclinato, la sua testa √® "sopra" la linea. Dobbiamo proiettare quel punto verticalmente a terra per trovare la sua posizione effettiva.</li></ul><p>Il nostro <strong>Strumento Giocatore (Y)</strong> risolve questo problema: ti costringe a definire il segmento "Corpo-Terra" (Ciano) e calcola la Linea di Fuorigioco (Arancione) partendo dal punto a terra, garantendo la correttezza prospettica.</p></div>`,
    toolsContent: `<div class="guide-section"><h3>üîß Dettaglio Strumenti</h3><div class="guide-step"><div class="guide-step-num">‚Üñ</div><div class="guide-step-content"><h4>Seleziona / Muovi VP (V)</h4><p>Permette di perfezionare il calcolo.<br>‚Ä¢ <strong>Trascina:</strong> Muovi il VP col mouse.<br>‚Ä¢ <strong>Frecce:</strong> Spostamento di precisione (1px).<br>‚Ä¢ <strong>Shift+Frecce:</strong> Spostamento rapido (10px).</p></div></div><div class="guide-step"><div class="guide-step-num">/</div><div class="guide-step-content"><h4>Linee di Riferimento (L)</h4><p><strong>Linee Blu.</strong> Tracciale su QUALSIASI linea orizzontale del campo. <br><em>Nota: Non tracciare sulle linee laterali verticali! Solo le orizzontali convergono al VP del fuorigioco.</em></p></div></div><div class="guide-step"><div class="guide-step-num">‚õπ</div><div class="guide-step-content"><h4>Proiezione Giocatore (Y)</h4><p><strong>Lo Strumento Pro.</strong><br>‚Ä¢ <strong>Click 1:</strong> Parte del corpo (Testa/Spalla).<br>‚Ä¢ <strong>Click 2:</strong> Punto a terra.<br>‚Ä¢ <strong>Risultato:</strong> Crea un segmento tratteggiato Ciano (altezza) e la linea finale Arancione.</p></div></div><div class="guide-step"><div class="guide-step-num">‚äï</div><div class="guide-step-content"><h4>Linea Manuale (P)</h4><p><strong>Linea Arancione.</strong> Utile se vuoi solo controllare un punto specifico a terra senza disegnare la proiezione del corpo.</p></div></div><div class="guide-step"><div class="guide-step-num">üîç</div><div class="guide-step-content"><h4>Lente Smart</h4><p>Si attiva automaticamente. Ora permette di vedere <strong>fuori dai bordi dell'immagine</strong>, rendendo facilissimo selezionare i pixel all'estremo limite dello screenshot.</p></div></div></div>`,
    aboutContent: `<div class="guide-section"><h3>‚öΩ Offside Calculator Pro</h3><p>Versione 3.2 - Strumento web professionale per analizzare posizioni di fuorigioco nel calcio utilizzando geometria prospettica e calcolo del punto di fuga.</p><div class="guide-highlight"><strong>Progetto Open Source</strong><br>Questo strumento √® gratuito e open source con licenza MIT. Puoi usarlo, modificarlo e distribuirlo liberamente.</div><h3>üë®‚Äçüíª Sviluppatore</h3><p><strong>Marco Verde</strong><br>Appassionato dell'intersezione tra matematica, computer vision e il gioco pi√π bello del mondo.</p><h3>üîó Collegamenti</h3><p>‚Ä¢ <strong>Repository GitHub:</strong> <a href="https://github.com/maverde73/offside-calculator" target="_blank" style="color: #00ff87;">github.com/maverde73/offside-calculator</a><br>‚Ä¢ <strong>Segnala Problemi:</strong> Trovato un bug? Hai un suggerimento? Apri una issue su GitHub!<br>‚Ä¢ <strong>Contribuisci:</strong> Le pull request sono benvenute!</p><h3>üìú Licenza</h3><p>Licenza MIT ¬© 2026 Marco Verde<br>Vedi il file LICENSE per i dettagli completi.</p><h3>üôè Ringraziamenti</h3><p>Realizzato con ‚ù§Ô∏è usando JavaScript vanilla e HTML5 Canvas. Un ringraziamento speciale alla community open source e a tutti i contributori.</p><p style="margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border); color: var(--text-muted); font-size: 0.875rem;"><em>Nota: Questo strumento √® per scopi educativi e analitici. Le decisioni ufficiali nelle partite sono prese da arbitri qualificati che utilizzano sistemi VAR professionali.</em></p></div>`
  }
};

let lang = 'en';
function t(k) { return i18n[lang][k] || i18n['en'][k] || k; }
function setLang(l) {
  lang = l;
  document.querySelectorAll('[data-i18n]').forEach(el => { const k = el.getAttribute('data-i18n'); if (i18n[l][k]) el.textContent = i18n[l][k]; });
  document.querySelectorAll('.lang-btn').forEach(b => b.classList.toggle('active', b.dataset.lang === l));
  updateStatus();
  const tab = document.querySelector('.modal-tab.active');
  if (tab) showTab(tab.dataset.tab);
}

// Geometry
const EPS = 1e-9;
function createLine(p1, p2) {
  const dx = p2.x - p1.x, dy = p2.y - p1.y;
  let a = -dy, b = dx, c = dy * p1.x - dx * p1.y;
  const n = Math.sqrt(a*a + b*b);
  return n < EPS ? null : { a: a/n, b: b/n, c: c/n, p1: {...p1}, p2: {...p2} };
}
function intersect(l1, l2) {
  const d = l1.a * l2.b - l1.b * l2.a;
  return Math.abs(d) < EPS ? null : { x: (l1.b * l2.c - l2.b * l1.c) / d, y: (l2.a * l1.c - l1.a * l2.c) / d };
}
function bestFit(lines) {
  if (lines.length < 2) return null;
  if (lines.length === 2) return intersect(lines[0], lines[1]);
  let sAA=0, sAB=0, sBB=0, sAC=0, sBC=0;
  for (const l of lines) { sAA += l.a*l.a; sAB += l.a*l.b; sBB += l.b*l.b; sAC += l.a*l.c; sBC += l.b*l.c; }
  const d = sAA * sBB - sAB * sAB;
  return Math.abs(d) < EPS ? null : { x: (sAB * sBC - sBB * sAC) / d, y: (sAB * sAC - sAA * sBC) / d };
}
function lineRect(line, rect) {
  const { a, b, c } = line, { left, top, right, bottom } = rect;
  const pts = [];
  if (Math.abs(b) > EPS) { let y = -(a * left + c) / b; if (y >= top && y <= bottom) pts.push({x: left, y}); y = -(a * right + c) / b; if (y >= top && y <= bottom) pts.push({x: right, y}); }
  if (Math.abs(a) > EPS) { let x = -(b * top + c) / a; if (x >= left && x <= right) pts.push({x, y: top}); x = -(b * bottom + c) / a; if (x >= left && x <= right) pts.push({x, y: bottom}); }
  const u = pts.filter((p, i) => !pts.slice(0, i).some(q => Math.abs(p.x-q.x)<1 && Math.abs(p.y-q.y)<1));
  return u.length >= 2 ? [u[0], u[1]] : null;
}
function distSq(a, b) { return (a.x-b.x)**2 + (a.y-b.y)**2; }

// State
let image = null, imageSize = {width: 0, height: 0};
let lines = [], vpPos = null, vpManual = false;
let tool = 'select', drawPt = null, mousePos = null, selectedId = null, draggingVP = false;
let view = {x: 0, y: 0, scale: 1}, isPanning = false, panStart = {x: 0, y: 0};
let history = ['[]'], historyIdx = 0;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvasContainer');

function toCanvas(sx, sy) { const r = canvas.getBoundingClientRect(); return { x: (sx - r.left - view.x) / view.scale, y: (sy - r.top - view.y) / view.scale }; }
function calcVP() { const src = lines.filter(l => !l.isVP && !l.isPlumb); return src.length >= 2 ? bestFit(src.map(l => l.geo)) : null; }
function updateLines(vp) {
  if (!vp) return;
  lines = lines.map(l => {
    if (!l.isVP) return l; 
    let anchor;
    if (l.srcPt) anchor = l.srcPt;
    else { const rect = {left: 0, top: 0, right: imageSize.width, bottom: imageSize.height}; const seg = lineRect(l.geo, rect); anchor = seg ? (distSq(seg[0], vp) > distSq(seg[1], vp) ? seg[0] : seg[1]) : l.geo.p2; }
    if (!anchor) return l;
    const g = createLine(vp, anchor);
    return g ? {...l, geo: g} : l;
  });
}
function saveHistory() { history = history.slice(0, historyIdx + 1); history.push(JSON.stringify(lines)); historyIdx = history.length - 1; }
function updateStatus() {
  const s = document.getElementById('statusHint');
  const m = { 
    select: t('statusSelect'), 
    draw: drawPt ? t('statusDraw2') : t('statusDraw1'), 
    vpLine: vpPos ? t('statusVP') : t('statusVPNone'),
    player: drawPt ? t('statusPlayer2') : t('statusPlayer1'),
    delete: t('statusDelete'), 
    pan: t('statusPan') 
  };
  s.textContent = m[tool];
  document.getElementById('vpX').textContent = vpPos ? vpPos.x.toFixed(1) : '--';
  document.getElementById('vpY').textContent = vpPos ? vpPos.y.toFixed(1) : '--';
  const st = document.getElementById('vpStatus');
  if (vpPos) { const inside = vpPos.x >= 0 && vpPos.x <= imageSize.width && vpPos.y >= 0 && vpPos.y <= imageSize.height; st.innerHTML = inside ? t('insideImage') : t('outsideImage'); st.className = 'vp-status ' + (inside ? 'inside' : 'outside'); }
  else { st.innerHTML = t('drawLines'); st.className = 'vp-status'; }
  document.getElementById('vpCoords').textContent = vpPos ? `VP: (${Math.round(vpPos.x)}, ${Math.round(vpPos.y)})` : 'VP: --';
  document.getElementById('sourceCount').textContent = lines.filter(l => !l.isVP && !l.isPlumb).length;
  document.getElementById('vpCount').textContent = lines.filter(l => l.isVP).length;
  document.getElementById('zoomIndicator').textContent = Math.round(view.scale * 100) + '%';
  document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.toggle('active', b.dataset.tool === tool));
  document.getElementById('emptyState').style.display = image ? 'none' : 'block';
  container.style.cursor = { select: 'default', draw: 'crosshair', vpLine: 'crosshair', player: 'crosshair', delete: 'pointer', pan: 'grab' }[tool] || 'default';
}
function render() {
  canvas.width = container.clientWidth; canvas.height = container.clientHeight;
  ctx.fillStyle = '#1e293b'; ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.save(); ctx.translate(view.x, view.y); ctx.scale(view.scale, view.scale);
  if (image) ctx.drawImage(image, 0, 0);
  const dr = { left: -view.x/view.scale - 200, top: -view.y/view.scale - 200, right: (canvas.width - view.x)/view.scale + 200, bottom: (canvas.height - view.y)/view.scale + 200 };
  
  // Render Lines
  for (const l of lines) {
    if (l.isPlumb) {
        // PLUMB LINE LOGIC (Draw Segment, not infinite line)
        const p1 = l.geo.p1;
        const p2 = l.geo.p2;
        
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.strokeStyle = '#22d3ee';
        ctx.lineWidth = 2/view.scale;
        ctx.setLineDash([2/view.scale, 3/view.scale]); // Fine dot
        ctx.stroke();
        
        // Marker Top (Body)
        ctx.beginPath(); ctx.arc(p1.x, p1.y, 4/view.scale, 0, Math.PI*2);
        ctx.fillStyle = '#22d3ee'; ctx.fill();
        
        // Marker Bottom (Ground - Crosshair)
        const cs = 5/view.scale;
        ctx.beginPath();
        ctx.moveTo(p2.x - cs, p2.y - cs); ctx.lineTo(p2.x + cs, p2.y + cs);
        ctx.moveTo(p2.x + cs, p2.y - cs); ctx.lineTo(p2.x - cs, p2.y + cs);
        ctx.strokeStyle = '#22d3ee'; ctx.setLineDash([]); ctx.lineWidth = 2/view.scale; ctx.stroke();

    } else {
        // INFINITE LINE LOGIC (For ref lines and VP lines)
        const seg = lineRect(l.geo, dr); if (!seg) continue;
        ctx.beginPath(); ctx.moveTo(seg[0].x, seg[0].y); ctx.lineTo(seg[1].x, seg[1].y);
        ctx.strokeStyle = l.id === selectedId ? '#fff' : l.color;
        ctx.lineWidth = (l.id === selectedId ? 4 : 3) / view.scale;
        ctx.setLineDash(l.isVP ? [12/view.scale, 6/view.scale] : []);
        ctx.shadowColor = l.color; ctx.shadowBlur = l.id === selectedId ? 10/view.scale : 5/view.scale;
        ctx.stroke(); ctx.shadowBlur = 0;
    }
  }
  ctx.setLineDash([]);
  
  // Drawing Preview
  if (drawPt && mousePos) {
    ctx.beginPath(); ctx.moveTo(drawPt.x, drawPt.y); ctx.lineTo(mousePos.x, mousePos.y);
    if (tool === 'player') {
        // Preview: Plumb style
        ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 2/view.scale;
        ctx.setLineDash([2/view.scale, 3/view.scale]); ctx.stroke();
        
        // Preview: Top Marker
        ctx.beginPath(); ctx.arc(drawPt.x, drawPt.y, 4/view.scale, 0, Math.PI*2);
        ctx.fillStyle = '#22d3ee'; ctx.fill();

        // Preview: Bottom Marker (X) at mouse
        const cs = 5/view.scale;
        ctx.beginPath();
        ctx.moveTo(mousePos.x - cs, mousePos.y - cs); ctx.lineTo(mousePos.x + cs, mousePos.y + cs);
        ctx.moveTo(mousePos.x + cs, mousePos.y - cs); ctx.lineTo(mousePos.x - cs, mousePos.y + cs);
        ctx.strokeStyle = '#22d3ee'; ctx.setLineDash([]); ctx.lineWidth = 2/view.scale; ctx.stroke();

        // Preview: Ghost offside line
        if (vpPos) {
             ctx.beginPath(); ctx.moveTo(mousePos.x, mousePos.y); ctx.lineTo(vpPos.x, vpPos.y);
             ctx.strokeStyle = 'rgba(249, 115, 22, 0.4)'; ctx.setLineDash([]); ctx.stroke();
        }
    } else {
        // Preview: Normal Line style
        ctx.strokeStyle = 'rgba(0, 255, 135, 0.6)'; ctx.lineWidth = 2/view.scale;
        ctx.setLineDash([8/view.scale, 4/view.scale]); ctx.stroke(); 
        ctx.setLineDash([]);
        ctx.beginPath(); ctx.arc(drawPt.x, drawPt.y, 4/view.scale, 0, Math.PI*2);
        ctx.fillStyle = '#00ff87'; ctx.fill();
    }
  }
  
  // Render VP
  if (vpPos) {
    const sz = 20/view.scale;
    ctx.shadowColor = '#00ff87'; ctx.shadowBlur = 20/view.scale;
    ctx.strokeStyle = '#00ff87'; ctx.lineWidth = 3/view.scale;
    ctx.beginPath(); ctx.moveTo(vpPos.x - sz*2, vpPos.y); ctx.lineTo(vpPos.x + sz*2, vpPos.y); ctx.moveTo(vpPos.x, vpPos.y - sz*2); ctx.lineTo(vpPos.x, vpPos.y + sz*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(vpPos.x, vpPos.y, sz, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(vpPos.x, vpPos.y, 4/view.scale, 0, Math.PI*2); ctx.fillStyle = '#00ff87'; ctx.fill();
    ctx.shadowBlur = 0;
  }
  ctx.restore(); 

  // --- MAGNIFIER LOGIC ---
  if (image && mousePos && (tool === 'draw' || tool === 'vpLine' || tool === 'player' || (tool==='select' && draggingVP))) {
      const magSize = 140; 
      const zoom = 4;
      const margin = 20;
      
      const rawMouseX = (mousePos.x * view.scale) + view.x;
      const rawMouseY = (mousePos.y * view.scale) + view.y;
      
      let mx = margin, my = margin;
      if (rawMouseX < magSize + margin*2 && rawMouseY < magSize + margin*2) {
          mx = canvas.width - magSize - margin;
      }

      ctx.save();
      ctx.fillStyle = '#000'; ctx.fillRect(mx, my, magSize, magSize);
      ctx.lineWidth = 2; ctx.strokeStyle = '#fff'; ctx.strokeRect(mx, my, magSize, magSize);
      
      ctx.beginPath(); ctx.rect(mx, my, magSize, magSize); ctx.clip();
      
      let srcW = magSize / zoom; let srcH = magSize / zoom;
      let srcX = mousePos.x - srcW / 2; let srcY = mousePos.y - srcH / 2;
      let dstX = 0, dstY = 0;
      
      if (srcX < 0) { dstX = -srcX * zoom; srcW += srcX; srcX = 0; }
      if (srcY < 0) { dstY = -srcY * zoom; srcH += srcY; srcY = 0; }
      if (srcX + srcW > image.width) srcW = image.width - srcX;
      if (srcY + srcH > image.height) srcH = image.height - srcY;

      if (srcW > 0 && srcH > 0) {
          ctx.drawImage(image, srcX, srcY, srcW, srcH, mx + dstX, my + dstY, srcW * zoom, srcH * zoom);
      }
      
      ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(mx + magSize/2, my); ctx.lineTo(mx + magSize/2, my + magSize);
      ctx.moveTo(mx, my + magSize/2); ctx.lineTo(mx + magSize, my + magSize/2); ctx.stroke();
      ctx.restore();
  }
  updateStatus();
}
function findLine(pos) { const th = 12/view.scale; for (const l of lines) { if (Math.abs(l.geo.a * pos.x + l.geo.b * pos.y + l.geo.c) < th) return l; } return null; }
function fitToView() { if (!image) return; const p = 40, sx = (container.clientWidth - p*2) / imageSize.width, sy = (container.clientHeight - p*2) / imageSize.height; view.scale = Math.min(sx, sy, 1); view.x = (container.clientWidth - imageSize.width * view.scale) / 2; view.y = (container.clientHeight - imageSize.height * view.scale) / 2; render(); }
function loadImageFile(file) { const r = new FileReader(); r.onload = e => { const img = new Image(); img.onload = () => { image = img; imageSize = {width: img.width, height: img.height}; lines = []; vpPos = null; vpManual = false; history = ['[]']; historyIdx = 0; fitToView(); }; img.src = e.target.result; }; r.readAsDataURL(file); }

canvas.addEventListener('mousedown', e => {
  const pos = toCanvas(e.clientX, e.clientY);
  if (vpPos && tool === 'select' && Math.sqrt(distSq(pos, vpPos)) < 25/view.scale) { draggingVP = true; return; }
  if (tool === 'pan' || e.button === 1) { isPanning = true; panStart = {x: e.clientX - view.x, y: e.clientY - view.y}; container.style.cursor = 'grabbing'; return; }
  
  if (tool === 'draw') { if (!drawPt) drawPt = pos; else { const g = createLine(drawPt, pos); if (g) { lines.push({id: Date.now(), geo: g, isVP: false, color: '#3b82f6'}); if (!vpManual) vpPos = calcVP(); saveHistory(); } drawPt = null; } }
  else if (tool === 'vpLine' && vpPos) { const g = createLine(vpPos, pos); if (g) { lines.push({id: Date.now(), geo: g, isVP: true, srcPt: pos, color: '#f97316'}); saveHistory(); } }
  else if (tool === 'player') {
      if (!drawPt) { drawPt = pos; } // Click 1: Body
      else { // Click 2: Ground
          const plumb = createLine(drawPt, pos);
          if (plumb) {
              lines.push({id: Date.now(), geo: plumb, isVP: false, isPlumb: true, color: '#22d3ee'});
              if (vpPos) { // Auto create Offside line
                  const vpL = createLine(vpPos, pos);
                  if (vpL) lines.push({id: Date.now()+1, geo: vpL, isVP: true, srcPt: pos, color: '#f97316'});
              }
              saveHistory();
          }
          drawPt = null;
      }
  }
  else if (tool === 'delete') { const l = findLine(pos); if (l) { lines = lines.filter(x => x.id !== l.id); if (!vpManual) vpPos = calcVP(); saveHistory(); } }
  else if (tool === 'select') { selectedId = findLine(pos)?.id || null; }
  render();
});
canvas.addEventListener('mousemove', e => { const pos = toCanvas(e.clientX, e.clientY); mousePos = pos; if (draggingVP) { vpManual = true; vpPos = pos; updateLines(pos); } if (isPanning) { view.x = e.clientX - panStart.x; view.y = e.clientY - panStart.y; } render(); });
canvas.addEventListener('mouseup', () => { if (draggingVP) saveHistory(); draggingVP = false; isPanning = false; if (tool === 'pan') container.style.cursor = 'grab'; });
canvas.addEventListener('wheel', e => { e.preventDefault(); const pos = toCanvas(e.clientX, e.clientY); const f = e.deltaY > 0 ? 0.9 : 1.1; view.scale = Math.max(0.05, Math.min(20, view.scale * f)); const r = canvas.getBoundingClientRect(); view.x = e.clientX - pos.x * view.scale - r.left; view.y = e.clientY - pos.y * view.scale - r.top; render(); }, {passive: false});
container.addEventListener('dragover', e => e.preventDefault());
container.addEventListener('drop', e => { e.preventDefault(); const f = e.dataTransfer.files[0]; if (f && f.type.startsWith('image/')) loadImageFile(f); });

document.addEventListener('keydown', e => {
  if (e.key === 'Escape') { drawPt = null; tool = 'select'; }
  else if (e.key === 'F1') { e.preventDefault(); openHelp(); }
  else if (e.key === 'v') tool = 'select';
  else if (e.key === 'l') tool = 'draw';
  else if (e.key === 'p') tool = 'vpLine';
  else if (e.key === 'y') tool = 'player';
  else if (e.key === 'd') tool = 'delete';
  else if (e.key === 'h') tool = 'pan';
  else if (e.key === ' ') { e.preventDefault(); tool = 'pan'; }
  else if (e.ctrlKey && e.key === 'z') { e.preventDefault(); if (historyIdx > 0) { historyIdx--; lines = JSON.parse(history[historyIdx]); vpManual = false; vpPos = calcVP(); } }
  else if (e.ctrlKey && e.key === 'y') { e.preventDefault(); if (historyIdx < history.length - 1) { historyIdx++; lines = JSON.parse(history[historyIdx]); } }
  else if (e.key === 'Delete' && selectedId) { lines = lines.filter(l => l.id !== selectedId); if (!vpManual) vpPos = calcVP(); saveHistory(); selectedId = null; }
  else if (vpPos && e.key.startsWith('Arrow')) { const d = e.shiftKey ? 10 : 1; let dx = 0, dy = 0; if (e.key === 'ArrowLeft') dx = -d/view.scale; if (e.key === 'ArrowRight') dx = d/view.scale; if (e.key === 'ArrowUp') dy = -d/view.scale; if (e.key === 'ArrowDown') dy = d/view.scale; if (dx || dy) { e.preventDefault(); vpManual = true; vpPos = {x: vpPos.x + dx, y: vpPos.y + dy}; updateLines(vpPos); } }
  render();
});
document.addEventListener('keyup', e => { if (e.key === ' ') { tool = 'select'; render(); } });

document.getElementById('btnOpen').onclick = () => document.getElementById('fileInput').click();
document.getElementById('fileInput').onchange = e => { const f = e.target.files?.[0]; if (f) loadImageFile(f); };
document.querySelectorAll('.tool-btn[data-tool]').forEach(b => { b.onclick = () => { tool = b.dataset.tool; drawPt = null; render(); }; });
document.getElementById('btnUndo').onclick = () => { if (historyIdx > 0) { historyIdx--; lines = JSON.parse(history[historyIdx]); vpManual = false; vpPos = calcVP(); render(); } };
document.getElementById('btnRedo').onclick = () => { if (historyIdx < history.length - 1) { historyIdx++; lines = JSON.parse(history[historyIdx]); render(); } };
document.getElementById('btnZoomIn').onclick = () => { view.scale *= 1.25; render(); };
document.getElementById('btnZoomOut').onclick = () => { view.scale *= 0.8; render(); };
document.getElementById('btnFit').onclick = fitToView;
document.getElementById('btnRecalc').onclick = () => { vpManual = false; vpPos = calcVP(); render(); };
document.querySelectorAll('.lang-btn').forEach(b => { b.onclick = () => setLang(b.dataset.lang); });

function exportImg(ext) {
  if (!image) return;
  let w = imageSize.width, h = imageSize.height, ox = 0, oy = 0;
  if (ext && vpPos) { const minX = Math.min(0, vpPos.x - 50), minY = Math.min(0, vpPos.y - 50), maxX = Math.max(w, vpPos.x + 50), maxY = Math.max(h, vpPos.y + 50); w = maxX - minX; h = maxY - minY; ox = -minX; oy = -minY; }
  const c = document.createElement('canvas'); c.width = w; c.height = h; const x = c.getContext('2d');
  x.fillStyle = '#1e293b'; x.fillRect(0, 0, w, h); x.drawImage(image, ox, oy);
  const rect = {left: -ox, top: -oy, right: w - ox, bottom: h - oy};
  for (const l of lines) { 
      if (l.isPlumb) {
          // EXPORT PLUMB STYLE
          const p1 = {x: l.geo.p1.x + ox, y: l.geo.p1.y + oy};
          const p2 = {x: l.geo.p2.x + ox, y: l.geo.p2.y + oy};
          x.beginPath(); x.moveTo(p1.x, p1.y); x.lineTo(p2.x, p2.y);
          x.strokeStyle = '#22d3ee'; x.lineWidth = 2; x.setLineDash([2, 3]); x.stroke();
          // Markers export
          x.setLineDash([]);
          x.beginPath(); x.arc(p1.x, p1.y, 4, 0, Math.PI*2); x.fillStyle = '#22d3ee'; x.fill();
          x.beginPath(); x.moveTo(p2.x - 5, p2.y - 5); x.lineTo(p2.x + 5, p2.y + 5); x.moveTo(p2.x + 5, p2.y - 5); x.lineTo(p2.x - 5, p2.y + 5); x.stroke();
      } else {
          const seg = lineRect(l.geo, rect); if (!seg) continue; x.beginPath(); x.moveTo(seg[0].x + ox, seg[0].y + oy); x.lineTo(seg[1].x + ox, seg[1].y + oy); 
          x.strokeStyle = l.color; x.lineWidth = 3; x.setLineDash(l.isVP ? [12, 6] : []); x.stroke();
      }
  }
  x.setLineDash([]);
  if (vpPos) { const vx = vpPos.x + ox, vy = vpPos.y + oy; x.strokeStyle = '#00ff87'; x.lineWidth = 3; x.beginPath(); x.moveTo(vx - 40, vy); x.lineTo(vx + 40, vy); x.moveTo(vx, vy - 40); x.lineTo(vx, vy + 40); x.stroke(); x.beginPath(); x.arc(vx, vy, 20, 0, Math.PI*2); x.stroke(); }

  // Watermark
  const wmText = 'github.com/maverde73/offside-calculator';
  x.font = '14px Montserrat, sans-serif';
  const wmWidth = x.measureText(wmText).width;
  const wmPadding = 12;
  const wmX = w - wmWidth - wmPadding * 2 - 10;
  const wmY = h - 30;
  x.fillStyle = 'rgba(0, 0, 0, 0.7)';
  x.fillRect(wmX - wmPadding, wmY - 18, wmWidth + wmPadding * 2, 28);
  x.fillStyle = '#00ff87';
  x.fillText(wmText, wmX, wmY);

  const a = document.createElement('a'); a.download = 'offside_analysis.png'; a.href = c.toDataURL('image/png'); a.click();
}
document.getElementById('btnExport').onclick = () => exportImg(false);
document.getElementById('btnExportExt').onclick = () => exportImg(true);

function openHelp() { document.getElementById('helpModal').classList.add('open'); showTab('quickstart'); }
function closeHelp() { document.getElementById('helpModal').classList.remove('open'); }
function showTab(tab) { document.querySelectorAll('.modal-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab)); document.getElementById('modalContent').innerHTML = t(tab + 'Content') || ''; }
document.getElementById('btnHelp').onclick = openHelp;
document.getElementById('btnCloseHelp').onclick = closeHelp;
document.getElementById('helpModal').onclick = e => { if (e.target.id === 'helpModal') closeHelp(); };
document.querySelectorAll('.modal-tab').forEach(tab => { tab.onclick = () => showTab(tab.dataset.tab); });
document.getElementById('btnTutorial').onclick = openHelp;

window.addEventListener('resize', render);
render();
</script>
</body>
</html>